package Model;

import java.util.LinkedList;
import java.util.NoSuchElementException;
import java.util.Random;
import java.util.Timer;
import java.util.TimerTask;

import View.GUIMain;

public class PassengersInQueue {

	// Object lock is used to synchronise code blocks for producer-consumer model
	// based threading
	private Object lock = new Object();
	
	// Constant used to limit the number if passengers in the economy and
	// first/business queues
	private final int ECOLIMIT = 20;
	private final int FIRSTLIMIT = 20;

	// Linked list shared data structures to store passengers generated by the
	// Producer thread
	// q1 for economy and q2 for first/business passengers
	private volatile LinkedList<Passenger> q1 = new LinkedList<Passenger>();
	private volatile LinkedList<Passenger> q2 = new LinkedList<Passenger>();

	// Linked list shared data structure to stored passengers who have checked in
	private volatile LinkedList<Passenger> Checkedin = new LinkedList<Passenger>();
	private volatile LinkedList<Passenger> forSecurity = new LinkedList<Passenger>();

	// Linked list shared data structure to stored passengers who have cleared
	// security
	private volatile LinkedList<Passenger> clearedSecurity = new LinkedList<Passenger>();

	// Linked list shared data structure to stored passengers who have cleared
	// security
	private volatile LinkedList<Passenger> boarding = new LinkedList<Passenger>();

	// Linked list shared data structure to stored passengers who have boarded Qatar
	// flight
	private volatile LinkedList<Passenger> Qatar = new LinkedList<Passenger>();

	// Linked list shared data structure to stored passengers who have boarded BA
	// flight
	private volatile LinkedList<Passenger> BA = new LinkedList<Passenger>();

	// Linked list shared data structure to stored passengers who have boarded
	// Emirates flight
	private volatile LinkedList<Passenger> Emirates = new LinkedList<Passenger>();

	// collection of passengers from the input file 'passengers'
	PassengerSet customers1 = new PassengerSet().populate();

	// Baggage object
	Baggage b;

	// method used in producer thread to populate the linked list data structures
	// with passengers travelling by economy class
	

	
	
	
	
	public void economyQueueputi() throws InterruptedException {

		System.out.println("Passengers in Economy class Check-in queue");
		Passenger p1;

		while (true) {

			// synchronised code block on the object lock which is shared between code
			// blocks of different methods
			synchronized (lock) {

				// released the lock if the size of q1 reaches the specified
				// LIMIT constant
				if(Thread.currentThread().isInterrupted()) {
                    Thread.sleep(1000000000);					}
				while (q1.size() == ECOLIMIT) {
					lock.wait();
				}

				// pick random passenger object p1 from the pool of passengers
				p1 = customers1.rando();

				// if condition to add economy class passengers in q1 linked list
				if (p1.getpClass().equalsIgnoreCase("economy")) {

					q1.add(p1);

					System.out.format(p1.getpClass() + " passenger," + p1.getFullName() + " travelling by flight "
							+ p1.getflightCode() + " is in the Economy check-in queue.");
					System.out.println();

					// this will print to the log report of programme execution
					String name = p1.getFullName();
					Log log = Log.getInstance();
					log.logCheckInQueue(name);

					// remove the passenger from the set to avoid duplication
					if (customers1.cont(p1)) {
						customers1.removeOb(p1);

					}
				}
				// once the synchronised code block is finished the lock is free and other
				// threads are notified to acquire the lock
				lock.notifyAll();
			}
		}
	}

	// method used in producer thread to populate the linked list data structures
	// with passengers travelling by first or business class
	public void firstbusinessQueueputi() throws InterruptedException {

		System.out.println("Passengers First & Business class in Check-in queue");
		Passenger p1;

		while (true) {

			// synchronised code block on the object lock which is shared between code
			// blocks of different methods
			synchronized (lock) {

				// released the lock if the size of q2 reaches the specified
				// LIMIT constant
				if(Thread.currentThread().isInterrupted()) {
                    Thread.sleep(1000000000);					}
				while (q2.size() == FIRSTLIMIT) {
					lock.wait();
				}

				// pick random passenger object p1 from the pool of passengers
				p1 = customers1.rando();

				// if condition to add first or business class passengers in q2 linked list
				if (p1.getpClass().equalsIgnoreCase("first") || p1.getpClass().equalsIgnoreCase("business")) {

					q2.add(p1);

					System.out.format(p1.getpClass() + " passenger," + p1.getFullName() + " travelling by flight "
							+ p1.getflightCode() + " is in the Business check-in queue.");
					System.out.println();

					// this will print to the log report of programme execution
					String name = p1.getFullName();
					Log log = Log.getInstance();
					log.logCheckInQueue(name);

					// remove the passenger from the set to avoid duplication
					if (customers1.cont(p1)) {
						customers1.removeOb(p1);

					}
				}
				// once the synchronised code block is finished the lock is free and other
				// threads are notified to acquire the lock
				lock.notifyAll();
			}
		}
	}

	// method to pick Economy class passenger as the Consumer form the linked list
	// q1
	public Passenger EconomyPicker() throws InterruptedException {

		// random class to make the thread sleep for random time within defined limits
		// used at the end of the code block
		Random random = new Random();

		// synchronised code block on the object lock which is shared between code
		// blocks of different methods
		synchronized (lock) {
			while (true) {

				try {

					// if condition to release the lock if there are no passengers in the q1 linked
					// list
					if(Thread.currentThread().isInterrupted()) {
                        Thread.sleep(1000000000);					}
					if (q1.size() == 0) {
						try{lock.wait();}catch(InterruptedException r) {
							
						}
					}

					// for loop to go through the linked list q1
					for (int i = 0; i <= q1.size(); i++) {

						// Passenger object p is the first element in the q1 linked list
						// remove() method will remove the object from the linked list
						Passenger p = q1.removeFirst();

						// for passenger travelling by economy class baggage b object is created
						Baggage b = p.createAbag(p);

						// the check-in status is set as true
						p.setCheckInStatus(true);

						// the passenger is added in the linked list Checkedin
						Checkedin.add(p);
						forSecurity.add(p);

						// This should be visible on GUIMain
						System.out.println(p.getpClass() + " class passenger, " + p.getFullName() + " travelling by "
								+ p.getflightCode() + " is Checking in at Economy Class " + "Check-in Desk");
						System.out.println("The check-in bag weight is " + b.getWeight() + " Kg and bag dimensions are "
								+ b.getHeight() + " X " + b.getBreadth() + " X " + b.getWidth()
								+ " cubic inches. Therefore, the baggage " + "volume is " + b.baggageVolume()
								+ " cubic inches");
						System.out.println("The check-in bag is overweight by " + b.excessBaggageWeight() + " kg.");
						System.out.println("The check-in bag exceeds volume allowance by " + b.excessBaggageVolume()
								+ " cubic inches.");
						System.out.println("The excess baggage fee is " + b.excessBaggageFee() + " GBP.");
						System.out.println("Total passengers checked in is " + Checkedin.size());
						System.out.println("Passengers ready for security: " + forSecurity.size());

						// this will print to the log report of programme execution
						String passengerClass = p.getpClass();
						String name = p.getFullName();
						String flightCode = p.getflightCode();
						Log log = Log.getInstance();
						log.logCheckInDeskEconomy(passengerClass, name, flightCode);

						// remove the passenger from the set to avoid duplication
						if (q1.contains(p)) {
							q1.remove(p);
						}

						// once the code block finishes the lock is released and other threads are
						// notified
						lock.notifyAll();

					}

					// catches two exceptions
				} catch (NullPointerException | NoSuchElementException N) {
					System.out.println("No economy class passengers waiting to be checked-in");
					
				}

				// the thread will randomly sleep for any milliseconds up to 1000
				try{Thread.sleep(random.nextInt(1000));}catch(InterruptedException r) {
					
				}
			}

		}

	}

	// method to pick Business or First class passengers form the queue q2
	public Passenger BusinessFirstPicker() throws InterruptedException {

		// random class to make the thread sleep for random time within defined limits
		// used at the end of the code block
		Random random = new Random();

		// synchronised code block on the object lock which is shared between code
		// blocks of different methods
		synchronized (lock) {
			while (true) {

				try {
					// if condition to release the lock if there are no passengers in the q2 linked
					// list
					if(Thread.currentThread().isInterrupted()) {
                        Thread.sleep(1000000000);					}
					if (q2.size() == 0) {
						lock.wait();
					}

					// for loop to go through the linked list q2
					for (int i = 0; i <= q2.size(); i++) {

						// Passenger object p is the first element in the q2 linked list
						// remove() method will remove the object from the linked list
						Passenger p = q2.removeFirst();

						// for passenger travelling by first or business class baggage b object is
						// created
						Baggage b = p.createAbag(p);

						// the check-in status is set as true
						p.setCheckInStatus(true);

						// the passenger is added in the linked list Checkedin
						Checkedin.add(p);
						forSecurity.add(p);

						// This should be visible on GUIMain
						System.out.println(p.getpClass() + " class passenger, " + p.getFullName() + " travelling by "
								+ p.getflightCode() + " is Checking in at Business & First Class Check-in Desk");
						System.out.println("The check-in bag weight is " + b.getWeight() + " Kg and bag dimensions are "
								+ b.getHeight() + " X " + b.getBreadth() + " X " + b.getWidth()
								+ " cubic inches. Therefore, the baggage " + "volume is " + b.baggageVolume()
								+ " cubic inches");
						System.out.println("The check-in bag is overweight by " + b.excessBaggageWeight() + " kg.");
						System.out.println("The check-in bag exceeds volume allowance by " + b.excessBaggageVolume()
								+ " cubic inches.");
						System.out.println("The excess baggage fee is " + b.excessBaggageFee() + " GBP.");
						System.out.println("Total number of passengers who have checked in is " + Checkedin.size());
						System.out.println("Passengers ready for security: " + forSecurity.size());

						// this will print to the log report of programme execution
						String passengerClass = p.getpClass();
						String name = p.getFullName();
						String flightCode = p.getflightCode();
						Log log = Log.getInstance();
						log.logCheckInDeskEconomy(passengerClass, name, flightCode);

						// remove the passenger from the set to avoid duplication
						if (q2.contains(p)) {
							q2.remove(p);
						}

						// once the code block finishes the lock is released and other threads are
						// notified
						lock.notifyAll();

					}
				} catch (NullPointerException | NoSuchElementException N) {
					System.out.println("No First or Business class passengers waiting to be checked-in");
				}
				try{Thread.sleep(random.nextInt(10));}catch(InterruptedException r) {
					
				}
			}

		}
	}

	// method to pick passengers who have checked in for security
	public Passenger securityPicker() throws InterruptedException {

		// random class to make the thread sleep for random time within defined limits
		// used at the end of the code block
		Random random = new Random();

		// synchronised code block on the object lock which is shared between code
		// blocks of different methods
		synchronized (lock) {
			while (true) {

				try {
					// if condition to release the lock if there are no passengers in the linked
					// list
					if(Thread.currentThread().isInterrupted()) {
                        try{Thread.sleep(1000000000);}catch(InterruptedException y) {
                        	}
                        }
					if (forSecurity.size() == 0) {
						lock.wait();
					}

					// for loop to go through the linked list
					for (int i = 0; i <= forSecurity.size(); i++) {

						// Passenger object p is the first element in the linked list
						// remove() method will remove the object from the linked list
						Passenger p = forSecurity.removeFirst();

						// if the passengers have checked in
						if (p.getCheckInStatus() == true) {

							// the passenger is added in the linked list security
							clearedSecurity.add(p);

							// This should be visible on GUIMain
							System.out.println(p.getpClass() + " class passenger, " + p.getFullName()
									+ " travelling by " + p.getflightCode() + " is in the security queue.");
							System.out.println("Total number of passengers who have cleared security is "
									+ clearedSecurity.size());

							// remove the passenger from the set to avoid duplication
							if (forSecurity.contains(p)) {
								forSecurity.remove(p);
							}

							// once the code block finishes the lock is released and other threads are
							// notified
							lock.notifyAll();
						}
					}

				} catch (NullPointerException | NoSuchElementException N) {
					System.out.println("No passengers in the security queue");
				}
				
				try{Thread.sleep(random.nextInt(100));}catch(InterruptedException r){
					
				}
			}

		}
	}

	// method to pick passengers who have cleared security for boarding
	public Passenger boardingPicker() throws InterruptedException {

		// random class to make the thread sleep for random time within defined limits
		// used at the end of the code block
		Random random = new Random();
		
	
		
     
   
		// synchronised code block on the object lock which is shared between code
		// blocks of different methods
		synchronized (lock) {
			while (true) {
      
				try {
					// if condition to release the lock if there are no passengers in the linked
					// list
					if(Thread.currentThread().isInterrupted()) {
                              Thread.sleep(1000000000);					}
					if (clearedSecurity.size() == 0) {
						try {
							lock.wait();
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}

					// for loop to go through the linked list
					for (int i = 0; i <= clearedSecurity.size(); i++) {

						// returns the first passenger object from the clearedSecurity linked list
						Passenger p = clearedSecurity.peekFirst();

						// the passenger object is checked for different conditions (flight code) to
						// populate
						// flight specific linked lists

						if (p.getCheckInStatus() == true && p.getflightCode().equalsIgnoreCase("QA410")) {

							// remove the first passenger if both the conditions in the if () are met
							clearedSecurity.removeFirst();

							// the passenger is added in the boarding linked list which is used
							// to check if all passengers from the input list have eventually boarded
							boarding.add(p);

							// This should be visible on GUIMain
							System.out.println(p.getpClass() + " class passenger, " + p.getFullName()
									+ " travelling by " + p.getflightCode() + " is in the boarding queue.");

							// sleep time to mimic boarding on flight
							try {
								Thread.sleep(random.nextInt(1000));
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
							}

							// flight data structure to mimic passengers on board
							Qatar.add(p);

							// to check the boarding progress
							System.out
									.println("Total number of passengers boarded on flight, QA410, is " + Qatar.size());
							System.out.println("Total number of passengers boarded is " + boarding.size());

							// remove the passenger from the set to avoid duplication
							if (clearedSecurity.contains(p)) {
								clearedSecurity.remove(p);
							}

						}

						else if (p.getCheckInStatus() == true && p.getflightCode().equalsIgnoreCase("BA808")) {

							// remove the first passenger if both the conditions in the if () are met
							clearedSecurity.removeFirst();

							// the passenger is added in the boarding linked list which is used
							// to check if all passengers from the input list have eventually boarded
							boarding.add(p);

							// This should be visible on GUIMain
							System.out.println(p.getpClass() + " class passenger, " + p.getFullName()
									+ " travelling by " + p.getflightCode() + " is in the boarding queue.");

							// sleep time to mimic boarding on flight
							try {
								Thread.sleep(random.nextInt(1000));
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								//e.printStackTrace();
							}

							// flight data structure to mimic passengers on board
							BA.add(p);

							// to check the boarding progress
							System.out.println("Total number of passengers boarded on flight,BA808, is " + BA.size());
							System.out.println("Total number of passengers boarded is " + boarding.size());

							// remove the passenger from the set to avoid duplication
							if (clearedSecurity.contains(p)) {
								clearedSecurity.remove(p);
							}

						} else if (p.getCheckInStatus() == true && p.getflightCode().equalsIgnoreCase("EA203")) {

							// remove the first passenger if both the conditions in the if () are met
							clearedSecurity.removeFirst();

							// the passenger is added in the boarding linked list which is used
							// to check if all passengers from the input list have eventually boarded

							boarding.add(p);

							// This should be visible on GUIMain
							System.out.println(p.getpClass() + " class passenger, " + p.getFullName()
									+ " travelling by " + p.getflightCode() + " is in the boarding queue.");

							// sleep time to mimic boarding on flight
							try {
								Thread.sleep(random.nextInt(1000));
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
							}

							// flight data structure to mimic passengers on board
							Emirates.add(p);

							// to check the boarding progress
							System.out.println(
									"Total number of passengers boarded on flight,EA203, is " + Emirates.size());
							System.out.println("Total number of passengers boarded is " + boarding.size());

							// remove the passenger from the set to avoid duplication
							if (clearedSecurity.contains(p)) {
								clearedSecurity.remove(p);
							}

						}

						// once the code block finishes the lock is released and other threads are
						// notified
						lock.notifyAll();

					}

				} catch (NullPointerException | NoSuchElementException N) {
					System.out.println("No passengers in the boarding queue");
				} catch (InterruptedException t) {
				}
				
				   try {	Thread.sleep(random.nextInt(100));}catch(InterruptedException t) {
					   
				   }
				
			}

		}
	}

	public LinkedList<Passenger> getQ() {
		return q1;
	}

	public LinkedList<Passenger> getQQ() {
		return q2;
	}

	public LinkedList<Passenger> getQ1() {
		return Checkedin;
	}

	public LinkedList<Passenger> getQ2() {
		return forSecurity;
	}

	public LinkedList<Passenger> getQQ2() {
		return clearedSecurity;
	}

	public LinkedList<Passenger> getQ3() {
		return boarding;
	}

	public LinkedList<Passenger> getQ4() {
		return Qatar;
	}

	public LinkedList<Passenger> getQ5() {
		return BA;
	}

	public LinkedList<Passenger> getQ6() {
		return Emirates;
	}

	public void addObserver(GUIMain guiMain) {
		// TODO Auto-generated method stub

	}





}