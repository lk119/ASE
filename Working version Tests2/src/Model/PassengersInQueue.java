package Model;

import java.util.LinkedList;
import java.util.NoSuchElementException;
import java.util.Random;
import View.GUIMain;

public class PassengersInQueue {

	// Object lock is used to synchronise code blocks for producer-consumer model
	// based threading
	private Object lock = new Object();

	// Constant used to limit the number if passengers in the economy and
	// first/business queues
	private final int ECOLIMIT = 5;
	private final int FIRSTLIMIT = 5;

	// Linked list shared data structures to store economy class passengers generated by the
	// Producer thread
	private volatile LinkedList<Passenger> q1 = new LinkedList<Passenger>();

	//Linked list to update the passenger check-in status
	private volatile LinkedList<Passenger> updater = new LinkedList<Passenger>();

	
	//return the updater linked list for passengers who have checked in 
	public LinkedList<Passenger> getUpdater() {
		return updater;
	}

	// set the linked link with passengers that have checked in
	public void setQ1(LinkedList<Passenger> updater) {
		this.updater = updater;
	}

	// Linked list shared data structures to store business or first class passengers generated by the
	// Producer thread
	private volatile LinkedList<Passenger> q2 = new LinkedList<Passenger>();

	
	// Linked list shared data structure to stored passengers who have checked in
	private volatile LinkedList<Passenger> Checkedin = new LinkedList<Passenger>();
	private volatile LinkedList<Passenger> forSecurity = new LinkedList<Passenger>();

	// Linked list shared data structure to stored passengers who have cleared
	// security
	private volatile LinkedList<Passenger> clearedSecurity = new LinkedList<Passenger>();

	// Linked list shared data structure to stored passengers who have cleared
	// security
	private volatile LinkedList<Passenger> boarding = new LinkedList<Passenger>();

	// Linked list shared data structure to stored passengers who have boarded Qatar
	// flight
	private volatile LinkedList<Passenger> Qatar = new LinkedList<Passenger>();

	// Linked list shared data structure to stored passengers who have boarded BA
	// flight
	private volatile LinkedList<Passenger> BA = new LinkedList<Passenger>();

	// Linked list shared data structure to stored passengers who have boarded
	// Emirates flight
	private volatile LinkedList<Passenger> Emirates = new LinkedList<Passenger>();

	//Linked list data structure to store bags when they are created
	private volatile LinkedList<Baggage> Bags = new LinkedList<Baggage>();

	//Linked list data structure to store flight weight capacity to carry bags for Qatar flight
	private volatile LinkedList<Double> QAflightweightCapacity = new LinkedList<Double>();

	//Linked list data structure to store flight volume capacity to carry bags for Qatar flight
	private volatile LinkedList<Double> QAflightvolumeCapacity = new LinkedList<Double>();

	//Linked list data structure to store excess baggage fees collected for Qatar flight
	private volatile LinkedList<Double> QAflightexcessbaggaefees = new LinkedList<Double>();

	//Linked list data structure to store flight weight capacity to carry bags for BA flight
	private volatile LinkedList<Double> BAflightweightCapacity = new LinkedList<Double>();

	//Linked list data structure to store flight volume capacity to carry bags for BA flight
	private volatile LinkedList<Double> BAflightvolumeCapacity = new LinkedList<Double>();

	//Linked list data structure to store excess baggage fees collected for BA flight
	private volatile LinkedList<Double> BAflightexcessbaggaefees = new LinkedList<Double>();

	//Linked list data structure to store flight weight capacity to carry bags for Emirates flight
	private volatile LinkedList<Double> EAflightweightCapacity = new LinkedList<Double>();

	//Linked list data structure to store flight volume capacity to carry bags for Emirates flight
	private volatile LinkedList<Double> EAflightvolumeCapacity = new LinkedList<Double>();
	
	//Linked list data structure to store excess baggage fees collected for Emirated flight
	private volatile LinkedList<Double> EAflightexcessbaggaefees = new LinkedList<Double>();

	// collection of passengers from the input file 'passengers'
	PassengerSet customers1 = new PassengerSet().populate();

	

	// method used in producer thread to populate the linked list data structures
	// with passengers travelling by economy class
	public LinkedList<Passenger> economyQueueputi() throws InterruptedException {

		System.out.println("Passengers in Economy class Check-in queue");
		Passenger p1;

		// synchronised code block on the object lock which is shared between code
		// blocks of different methods

		synchronized (lock) {

			// released the lock if the size of q1 reaches the specified
			// LIMIT constant
			try {
				while (q1.size() == ECOLIMIT) {
					lock.wait();
				}
			} catch (InterruptedException u) {

			}

			// pick random passenger object p1 from the pool of passengers
			p1 = customers1.rando();

			// if condition to add economy class passengers in q1 linked list
			if (p1.getpClass().equalsIgnoreCase("economy") && customers1 != null) {

				q1.add(p1);
				setQ1(q1);
				System.out.format(p1.getpClass() + " passenger," + p1.getFullName() + " travelling by flight "
						+ p1.getflightCode() + " is in the Economy check-in queue.");
				System.out.println();

				// this will print to the log report of programme execution
				String name = p1.getFullName();
				String Class = p1.getpClass();
				String flightCode = p1.getflightCode();
				Log log = Log.getInstance();
				log.logCheckInQueue(name, Class, flightCode);

				// remove the passenger from the set to avoid duplication
				if (customers1.cont(p1)) {
					customers1.removeOb(p1);

				}
			}
			// once the synchronised code block is finished the lock is free and other
			// threads are notified to acquire the lock
			lock.notifyAll();
		}

		//returns the linked list with economy class passengers
		return q1;

	}

	// method used in producer thread to populate the linked list data structures
	// with passengers travelling by first or business class
	public LinkedList<Passenger> firstbusinessQueueputi() throws InterruptedException {

		System.out.println("Passengers First & Business class in Check-in queue");
		Passenger p1;

		// synchronised code block on the object lock which is shared between code
		// blocks of different methods
		synchronized (lock) {

			// released the lock if the size of q2 reaches the specified
			// LIMIT constant
			try {
				while (q2.size() == FIRSTLIMIT) {
					lock.wait();
				}
			} catch (InterruptedException u) {

			}

			// pick random passenger object p1 from the pool of passengers
			p1 = customers1.rando();

			// if condition to add first or business class passengers in q2 linked list
			if (p1.getpClass().equalsIgnoreCase("first")
					|| p1.getpClass().equalsIgnoreCase("business") && customers1 != null) {

				q2.add(p1);

				System.out.format(p1.getpClass() + " passenger," + p1.getFullName() + " travelling by flight "
						+ p1.getflightCode() + " is in the Business check-in queue.");
				System.out.println();

				// this will print to the log report of programme execution
				String name = p1.getFullName();
				String Class = p1.getpClass();
				String flightCode = p1.getflightCode();
				Log log = Log.getInstance();
				log.logCheckInQueue(name, Class, flightCode);

				// remove the passenger from the set to avoid duplication
				if (customers1.cont(p1)) {
					customers1.removeOb(p1);

				}
			}
			
			// once the synchronised code block is finished the lock is free and other
			// threads are notified to acquire the lock
			lock.notifyAll();
		}
		
		//returns the linked list with first and business class passengers
		return q2;
	}

	
	// method to pick Economy class passenger as the Consumer form the linked list
	// q1
	public Baggage EconomyPicker() throws InterruptedException {

		// random class to make the thread sleep for random time within defined limits
		// used at the end of the code block
		Random random = new Random();
		Passenger p = null;
		Baggage b = null;
		
		// synchronised code block on the object lock which is shared between code
		// blocks of different methods
		synchronized (lock) {

			try {

				// if condition to release the lock if there are no passengers in the q1 linked
				// list
				if (q1.size() == 0) {
					lock.wait();
				}

				// for loop to go through the linked list q1
				for (int i = 0; i <= q1.size(); i++) {

					// Passenger object p is the first element in the q1 linked list
					// remove() method will remove the object from the linked list
					p = q1.removeFirst();

					// for passenger travelling by economy class baggage b object is created
					b = p.createAbag(p);
					
					// add the checked-in bag in the Bags Linked List
					Bags.add(b);

					// calculate the flight weight capacity reached
					double weightCapacity = ((b.getWeight() / 3000) * 100);

					// calculate the flight volume capacity reached
					double volumeCapacity = ((b.baggageVolume() / 80000) * 100);

					// calculate the excess baggage fees collected
					double baggageFees = b.excessBaggageFee();

					// add the values from the above calculations into respective linked lists
					if (p.getflightCode().equalsIgnoreCase("QA410")) {

						QAflightweightCapacity.add(weightCapacity);
						QAflightvolumeCapacity.add(volumeCapacity);
						QAflightexcessbaggaefees.add(baggageFees);
					} else if (p.getflightCode().equalsIgnoreCase("BA808")) {

						BAflightweightCapacity.add(weightCapacity);
						BAflightvolumeCapacity.add(volumeCapacity);
						BAflightexcessbaggaefees.add(baggageFees);
					}

					else if (p.getflightCode().equalsIgnoreCase("EA203")) {

						EAflightweightCapacity.add(weightCapacity);
						EAflightvolumeCapacity.add(volumeCapacity);
						EAflightexcessbaggaefees.add(baggageFees);
					}

					// the check-in status is set as true
					p.setCheckInStatus(true);

					// the passenger is added in the linked list Checkedin
					Checkedin.add(p);
					forSecurity.add(p);

					// This should be visible on GUIMain
					System.out.println(p.getpClass() + " class passenger, " + p.getFullName() + " travelling by "
							+ p.getflightCode() + " is Checking in at Economy Class " + "Check-in Desk");
					System.out.println("The check-in bag weight is " + b.getWeight() + " Kg and bag dimensions are "
							+ b.getHeight() + " X " + b.getBreadth() + " X " + b.getWidth()
							+ " cubic inches. Therefore, the baggage " + "volume is " + b.baggageVolume()
							+ " cubic inches");
					System.out.println("The check-in bag is overweight by " + b.excessBaggageWeight() + " kg.");
					System.out.println("The check-in bag exceeds volume allowance by " + b.excessBaggageVolume()
							+ " cubic inches.");
					System.out.println("The excess baggage fee is " + b.excessBaggageFee() + " GBP.");
					System.out.println("Total passengers checked in is " + Checkedin.size());
					System.out.println("Passengers ready for security: " + forSecurity.size());
					System.out.println("Total number of bags = " + Bags.size());

					if (p.getflightCode().equalsIgnoreCase("QA410")) {

						System.out.println(
								"Qantas QA410 flight weight capacity reached is " + QAtotalWeightCapacity() + "%");
						System.out.println(
								"Qantas QA410 flight volume capacity reached is " + QAtotalVolumeCapacity() + "%");
						System.out.println("Total excess baggage fees collected for Qantas QA410 is "
								+ QAtotalExcessFeesCollected() + " GBP.");
					} else if (p.getflightCode().equalsIgnoreCase("BA808")) {

						System.out.println("British Airways BA808 flight weight capacity reached is "
								+ BAtotalWeightCapacity() + "%");
						System.out.println("British Airways BA808  flight volume capacity reached is "
								+ BAtotalVolumeCapacity() + "%");
						System.out.println("Total excess baggage fees collected for British Airways BA808 is "
								+ BAtotalExcessFeesCollected() + " GBP.");
					}

					else if (p.getflightCode().equalsIgnoreCase("EA203")) {

						System.out.println(
								"Emirates EA203 flight weight capacity reached is " + EAtotalWeightCapacity() + "%");
						System.out.println(
								"Emirates EA203 flight volume capacity reached is " + EAtotalVolumeCapacity() + "%");
						System.out.println("Total excess baggage fees collected for Emirates EA203 is "
								+ EAtotalExcessFeesCollected() + " GBP.");
					}

					
					// this will print to the log report of programme execution
					String passengerClass = p.getpClass();
					String name = p.getFullName();
					String flightCode = p.getflightCode();
					String bag = b.getHeight() + " X " + b.getBreadth() + " X " + b.getWidth() + " cubic inches.";
					String bagWeight = b.getWeight() + "";
					String fees = b.excessBaggageFee() + " GBP";
					Log log = Log.getInstance();
					log.logCheckInDesk(passengerClass, name, flightCode, bag, bagWeight, fees);

					// remove the passenger from the set to avoid duplication
					if (q1.contains(p)) {
						q1.remove(p);
					}

					// once the code block finishes the lock is released and other threads are
					// notified
					lock.notifyAll();

				}

				// catches two exceptions
			} catch (NullPointerException | NoSuchElementException N) {
				System.out.println("No economy class passengers waiting to be checked-in");
			}

			// the thread will randomly sleep for any milliseconds up to 1000
			Thread.sleep(random.nextInt(1000));
		}
		
		//returns the baggage object
		return b;
	}

	// method to pick Business or First class passengers form the queue q2
	public Baggage BusinessFirstPicker() throws InterruptedException {

		// random class to make the thread sleep for random time within defined limits
		// used at the end of the code block
		Random random = new Random();
		Passenger p = null;
		Baggage b = null;

		// synchronised code block on the object lock which is shared between code
		// blocks of different methods
		synchronized (lock) {

			try {
				// if condition to release the lock if there are no passengers in the q2 linked
				// list
				if (q2.size() == 0) {
					lock.wait();
				}

				// for loop to go through the linked list q2
				for (int i = 0; i <= q2.size(); i++) {

					// Passenger object p is the first element in the q2 linked list
					// remove() method will remove the object from the linked list
					p = q2.removeFirst();

					// for passenger travelling by first or business class baggage b object is
					// created
					b = p.createAbag(p);

					// calculate the flight weight capacity reached
					double weightCapacity = ((b.getWeight() / 20000) * 100);

					// calculate the flight volume capacity reached
					double volumeCapacity = ((b.baggageVolume() / 30000) * 100);

					// calculate the excess baggage fees collected
					double baggageFees = b.excessBaggageFee();

					// add the values from the above calculations into respective linked lists
					if (p.getflightCode().equalsIgnoreCase("QA410")) {

						QAflightweightCapacity.add(weightCapacity);
						QAflightvolumeCapacity.add(volumeCapacity);
						QAflightexcessbaggaefees.add(baggageFees);
					} else if (p.getflightCode().equalsIgnoreCase("BA808")) {

						BAflightweightCapacity.add(weightCapacity);
						BAflightvolumeCapacity.add(volumeCapacity);
						BAflightexcessbaggaefees.add(baggageFees);
					}

					else if (p.getflightCode().equalsIgnoreCase("EA203")) {

						EAflightweightCapacity.add(weightCapacity);
						EAflightvolumeCapacity.add(volumeCapacity);
						EAflightexcessbaggaefees.add(baggageFees);
					}

					// the check-in status is set as true
					p.setCheckInStatus(true);

					// the passenger is added in the linked list Checkedin
					Checkedin.add(p);
					forSecurity.add(p);

					// This should be visible on GUIMain
					System.out.println(p.getpClass() + " class passenger, " + p.getFullName() + " travelling by "
							+ p.getflightCode() + " is Checking in at Business & First Class Check-in Desk");
					System.out.println("The check-in bag weight is " + b.getWeight() + " Kg and bag dimensions are "
							+ b.getHeight() + " X " + b.getBreadth() + " X " + b.getWidth()
							+ " cubic inches. Therefore, the baggage " + "volume is " + b.baggageVolume()
							+ " cubic inches");
					System.out.println("The check-in bag is overweight by " + b.excessBaggageWeight() + " kg.");
					System.out.println("The check-in bag exceeds volume allowance by " + b.excessBaggageVolume()
							+ " cubic inches.");
					System.out.println("The excess baggage fee is " + b.excessBaggageFee() + " GBP.");
					System.out.println("Total number of passengers who have checked in is " + Checkedin.size());
					System.out.println("Passengers ready for security: " + forSecurity.size());

					if (p.getflightCode().equalsIgnoreCase("QA410")) {

						System.out.println(
								"Qantas QA410 flight weight capacity reached is " + QAtotalWeightCapacity() + "%");
						System.out.println(
								"Qantas QA410 flight volume capacity reached is " + QAtotalVolumeCapacity() + "%");
						System.out.println("Total excess baggage fees collected for Qantas QA410 is "
								+ QAtotalExcessFeesCollected() + " GBP.");
					} else if (p.getflightCode().equalsIgnoreCase("BA808")) {

						System.out.println("British Airways BA808 flight weight capacity reached is "
								+ BAtotalWeightCapacity() + "%");
						System.out.println("British Airways BA808  flight volume capacity reached is "
								+ BAtotalVolumeCapacity() + "%");
						System.out.println("Total excess baggage fees collected for British Airways BA808 is "
								+ BAtotalExcessFeesCollected() + " GBP.");
					}

					else if (p.getflightCode().equalsIgnoreCase("EA203")) {

						System.out.println(
								"Emirates EA203 flight weight capacity reached is " + EAtotalWeightCapacity() + "%");
						System.out.println(
								"Emirates EA203 flight volume capacity reached is " + EAtotalVolumeCapacity() + "%");
						System.out.println("Total excess baggage fees collected for Emirates EA203 is "
								+ EAtotalExcessFeesCollected() + " GBP.");
					}

					// this will print to the log report of programme execution
					String passengerClass = p.getpClass();
					String name = p.getFullName();
					String flightCode = p.getflightCode();
					String bag = b.getHeight() + " X " + b.getBreadth() + " X " + b.getWidth() + " cubic inches.";
					String bagWeight = b.getWeight() + "";
					String fees = b.excessBaggageFee() + " GBP";
					Log log = Log.getInstance();
					log.logCheckInDesk(passengerClass, name, flightCode, bag, bagWeight, fees);

					// remove the passenger from the set to avoid duplication
					if (q2.contains(p)) {
						q2.remove(p);
					}

					// once the code block finishes the lock is released and other threads are
					// notified
					lock.notifyAll();

				}
			} catch (NullPointerException | NoSuchElementException N) {
				System.out.println("No First or Business class passengers waiting to be checked-in");
			}
		}
		
		//returns the baggage object
		return b;

	}

	// method to pick passengers who have checked in for security
	public LinkedList<Passenger> securityPicker() throws InterruptedException {

		// random class to make the thread sleep for random time within defined limits
		// used at the end of the code block
		Random random = new Random();

		// synchronised code block on the object lock which is shared between code
		// blocks of different methods
		synchronized (lock) {

			try {
				// if condition to release the lock if there are no passengers in the linked
				// list
				if (forSecurity.size() == 0) {
					lock.wait();
				}

				// for loop to go through the linked list
				for (int i = 0; i <= forSecurity.size(); i++) {

					// Passenger object p is the first element in the linked list
					// remove() method will remove the object from the linked list
					Passenger p = forSecurity.removeFirst();

					// if the passengers have checked in
					if (p.getCheckInStatus() == true) {

						// the passenger is added in the linked list security
						clearedSecurity.add(p);

						// This should be visible on GUIMain
						System.out.println(p.getpClass() + " class passenger, " + p.getFullName() + " travelling by "
								+ p.getflightCode() + " is in the security queue.");
						System.out.println(
								"Total number of passengers who have cleared security is " + clearedSecurity.size());

						// remove the passenger from the set to avoid duplication
						if (forSecurity.contains(p)) {
							forSecurity.remove(p);
						}

						// once the code block finishes the lock is released and other threads are
						// notified
						lock.notifyAll();
					}
				}

			} catch (NullPointerException | NoSuchElementException N) {
				System.out.println("No passengers in the security queue");
			}
			Thread.sleep(random.nextInt(100));
		}
		
		// linked list with passengers who have cleared security
		return clearedSecurity;
	}

	// method to pick passengers who have cleared security for boarding
	public LinkedList<Passenger> boardingPicker() throws InterruptedException {

		// random class to make the thread sleep for random time within defined limits
		// used at the end of the code block
		Random random = new Random();

		// synchronised code block on the object lock which is shared between code
		// blocks of different methods
		synchronized (lock) {

			try {
				// if condition to release the lock if there are no passengers in the linked
				// list
				if (clearedSecurity.size() == 0) {
					lock.wait();
				}

				// for loop to go through the linked list
				for (int i = 0; i <= clearedSecurity.size(); i++) {

					// returns the first passenger object from the clearedSecurity linked list
					Passenger p = clearedSecurity.peekFirst();

					// the passenger object is checked for different conditions (flight code) to
					// populate
					// flight specific linked lists

					if (p.getCheckInStatus() == true && p.getflightCode().equalsIgnoreCase("QA410")) {

						// remove the first passenger if both the conditions in the if () are met
						clearedSecurity.removeFirst();

						// the passenger is added in the boarding linked list which is used
						// to check if all passengers from the input list have eventually boarded
						boarding.add(p);

						// This should be visible on GUIMain
						System.out.println(p.getpClass() + " class passenger, " + p.getFullName() + " travelling by "
								+ p.getflightCode() + " is in the boarding queue.");

						// sleep time to mimic boarding on flight
						Thread.sleep(random.nextInt(1000));

						// flight data structure to mimic passengers on board
						Qatar.add(p);

						// to check the boarding progress
						System.out.println("Total number of passengers boarded on flight, QA410, is " + Qatar.size());
						System.out.println("Total number of passengers boarded is " + boarding.size());

						// remove the passenger from the set to avoid duplication
						if (clearedSecurity.contains(p)) {
							clearedSecurity.remove(p);
						}

					}

					else if (p.getCheckInStatus() == true && p.getflightCode().equalsIgnoreCase("BA808")) {

						// remove the first passenger if both the conditions in the if () are met
						clearedSecurity.removeFirst();

						// the passenger is added in the boarding linked list which is used
						// to check if all passengers from the input list have eventually boarded
						boarding.add(p);

						// This should be visible on GUIMain
						System.out.println(p.getpClass() + " class passenger, " + p.getFullName() + " travelling by "
								+ p.getflightCode() + " is in the boarding queue.");

						// sleep time to mimic boarding on flight
						Thread.sleep(random.nextInt(1000));

						// flight data structure to mimic passengers on board
						BA.add(p);

						// to check the boarding progress
						System.out.println("Total number of passengers boarded on flight,BA808, is " + BA.size());
						System.out.println("Total number of passengers boarded is " + boarding.size());

						// remove the passenger from the set to avoid duplication
						if (clearedSecurity.contains(p)) {
							clearedSecurity.remove(p);
						}

					} else if (p.getCheckInStatus() == true && p.getflightCode().equalsIgnoreCase("EA203")) {

						// remove the first passenger if both the conditions in the if () are met
						clearedSecurity.removeFirst();

						// the passenger is added in the boarding linked list which is used
						// to check if all passengers from the input list have eventually boarded

						boarding.add(p);

						// This should be visible on GUIMain
						System.out.println(p.getpClass() + " class passenger, " + p.getFullName() + " travelling by "
								+ p.getflightCode() + " is in the boarding queue.");

						// sleep time to mimic boarding on flight
						Thread.sleep(random.nextInt(1000));

						// flight data structure to mimic passengers on board
						Emirates.add(p);

						// to check the boarding progress
						System.out.println("Total number of passengers boarded on flight,EA203, is " + Emirates.size());
						System.out.println("Total number of passengers boarded is " + boarding.size());

						// remove the passenger from the set to avoid duplication
						if (clearedSecurity.contains(p)) {
							clearedSecurity.remove(p);
						}

					}

					// once the code block finishes the lock is released and other threads are
					// notified
					lock.notifyAll();

				}

			} catch (NullPointerException | NoSuchElementException N) {
				System.out.println("No passengers in the boarding queue");
			}
			Thread.sleep(random.nextInt(100));
		}

		//returns linked list of passengers in boarding queue
		return boarding;
	}
	
	
	public synchronized PassengerSet getCustomers1() {
		return customers1;
	}
	
	
	
	public synchronized LinkedList<Passenger> getQ() {
		return q1;
	}

	public synchronized LinkedList<Passenger> getQQ() {
		return q2;
	}

	public synchronized LinkedList<Passenger> getQ1() {
		return Checkedin;
	}

	public synchronized LinkedList<Passenger> getQ2() {
		return forSecurity;
	}

	public synchronized LinkedList<Passenger> getQQ2() {
		return clearedSecurity;
	}

	public synchronized LinkedList<Passenger> getQ3() {
		return boarding;
	}

	public synchronized LinkedList<Passenger> getQ4() {
		return Qatar;
	}

	public synchronized LinkedList<Passenger> getQ5() {
		return BA;
	}

	public LinkedList<Passenger> getQ6() {
		return Emirates;
	}

	public synchronized LinkedList<Baggage> getB() {
		return Bags;
	}

	public void addObserver(GUIMain guiMain) {
		// TODO Auto-generated method stub

	}

	public synchronized double QAtotalWeightCapacity() {

		double sum = 0;
		for (int i = 0; i < QAflightweightCapacity.size(); i++) {
			sum += QAflightweightCapacity.get(i);

		}

		return sum;
	}

	public synchronized double QAtotalVolumeCapacity() {
		double sum = 0;
		for (int i = 0; i < QAflightvolumeCapacity.size(); i++)
			sum += QAflightvolumeCapacity.get(i);
		return sum;
	}

	public synchronized double QAtotalExcessFeesCollected() {
		double sum = 0;
		for (int i = 0; i < QAflightexcessbaggaefees.size(); i++)
			sum += QAflightexcessbaggaefees.get(i);
		return sum;
	}

	public synchronized double BAtotalWeightCapacity() {

		double sum = 0;
		for (int i = 0; i < BAflightweightCapacity.size(); i++) {
			sum += BAflightweightCapacity.get(i);

		}

		return sum;
	}

	public synchronized double BAtotalVolumeCapacity() {
		double sum = 0;
		for (int i = 0; i < BAflightvolumeCapacity.size(); i++)
			sum += BAflightvolumeCapacity.get(i);
		return sum;
	}

	public synchronized double BAtotalExcessFeesCollected() {
		double sum = 0;
		for (int i = 0; i < BAflightexcessbaggaefees.size(); i++)
			sum += BAflightexcessbaggaefees.get(i);
		return sum;
	}

	public synchronized double EAtotalWeightCapacity() {

		double sum = 0;
		for (int i = 0; i < EAflightweightCapacity.size(); i++) {
			sum += EAflightweightCapacity.get(i);

		}

		return sum;
	}

	public synchronized double EAtotalVolumeCapacity() {
		double sum = 0;
		for (int i = 0; i < EAflightvolumeCapacity.size(); i++)
			sum += EAflightvolumeCapacity.get(i);
		return sum;
	}

	public synchronized double EAtotalExcessFeesCollected() {
		double sum = 0;
		for (int i = 0; i < EAflightexcessbaggaefees.size(); i++)
			sum += EAflightexcessbaggaefees.get(i);
		return sum;
	}

}