package Model;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Random;
import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import View.GUIMain;

public class PassengersInQueue {

	
	//Object lock is used to synchronise code blocks for producer-consumer model based threading
	private Object lock = new Object();
	
	//Constant used to limit the number if passengers in the queue
	private final int LIMIT = 15;
	

	//Linked list shared data structures to store passengers generated by the Producer thread
	private volatile LinkedList<Passenger> q1 = new LinkedList<Passenger>();
	private volatile LinkedList<Passenger> q2 = new LinkedList<Passenger>();

	//Linked list shared data structure to stored passengers who have checked in
	private volatile LinkedList<Passenger> Checkedin = new LinkedList<Passenger>();
	
	//Linked list shared data structure to stored passengers who have cleared security
	private volatile LinkedList<Passenger> security = new LinkedList<Passenger>();
	
	//Linked list shared data structure to stored passengers who have cleared security
	private volatile LinkedList<Passenger> boarding = new LinkedList<Passenger>();

	// our flight fleet
	//FlightList planes = new FlightList().populate();

	// collection of passengers from the input file 'passengers'
	PassengerSet customers1 = new PassengerSet().populate();

	// Baggage object
	Baggage b;

	
	// method used in producer thread to populate the linked list data structures
	public void puti() throws InterruptedException {
		
		System.out.println("Passengers in Check-in queue");
		Passenger p1;
		
		while (true) {
			
			//synchronised code block on the object lock which is shared between code blocks of different methods
			synchronized (lock) {

				// pick random passenger object p1 from the pool of passengers
				p1 = customers1.rando();

				// add passenger and baggage in linked list q1 and q2
				q1.add(p1);
				q2.add(p1);

				System.out.format(p1.getpClass() + " passenger," + p1.getFullName() + " travelling by flight "
						+ p1.getflightCode() + " is in the check-in queue.");
				System.out.println();

				// released the lock if the size of q2 (can also be q1) reaches the specified LIMIT constant
				while (q2.size() == LIMIT) {
					lock.wait();
				}
				
				// this will print to the log report of programme execution
				String name = p1.getFullName();
                Log log = Log.getInstance();
				log.logCheckInQueue(name);

				// remove the passenger from the set to avoid duplication
				if (customers1.cont(p1)) {
					customers1.removeOb(p1);
					
				}
				
				// once the synchronised code block is finished the lock is free and other threads are notified to acquire the lock
				lock.notifyAll();
			}
		}
	}

	
	

	// method to pick Economy class passenger as the Consumer form the linked list q1
	public Passenger EconomyPicker() throws InterruptedException {

		//random class to make the thread sleep for random time within defined limits
		//used at the end of the code block
		Random random = new Random();

		//synchronised code block on the object lock which is shared between code blocks of different methods
		synchronized (lock) {
			while (true) {

				try {

					//if condition to release the lock if there are no passengers in the q1 linked list
					if (q1.size() == 0) {
						lock.wait();
					}

					//for loop to go through the linked list q1
					for (int i = 0; i <= q1.size(); i++) {

						// Passenger object p is the first element in the q1 linked list
						//remove() method will remove the object from the linked list
						Passenger p = q1.removeFirst();
						
                        //if condition to process the p object as indicated if the class in economy 
						if (p.getpClass().equalsIgnoreCase("economy")) {

							//for passenger travelling by economy class baggage b object is created
							Baggage b = p.createAbag(p);
							
							//the check-in status is set as true
							p.setCheckInStatus(true);
							
							//the passenger is added in the linked list Checkedin
							Checkedin.add(p);
							
							//This should be visible on GUIMain
							System.out.println(p.getpClass() + " class passenger, " + p.getFullName()
									+ " travelling by " + p.getflightCode() + " is Checking in at Economy Class "
									+ "Check-in Desk");
							System.out.println("The check-in bag weight is " + b.getWeight()
									+ " Kg and bag dimensions are " + b.getHeight() + " X " + b.getBreadth() + " X "
									+ b.getWidth() + " cubic inches. Therefore, the baggage " + "volume is "
									+ b.baggageVolume() + " cubic inches");
							System.out.println("The check-in bag is overweight by " + b.excessBaggageWeight() + " kg.");
							System.out.println("The check-in bag exceeds volume allowance by " + b.excessBaggageVolume()
									+ " cubic inches.");
							System.out.println("The excess baggage fee is " + b.excessBaggageFee() + " GBP.");
							System.out.println("Total passengers checked in is " + Checkedin.size());
							
							// this will print to the log report of programme execution
							String passengerClass = p.getpClass();
							String name = p.getFullName();
							String flightCode = p.getflightCode();
							Log log = Log.getInstance();
							log.logCheckInDeskEconomy(passengerClass, name, flightCode);

							// remove the passenger from the set to avoid duplication
							if (q1.contains(p)) {
								q1.remove(p);

							}
							
                            //once the code block finishes the lock is released and other threads are notified
							lock.notifyAll();

						}
					}
					
					//catches two exceptions
				} catch (NullPointerException | NoSuchElementException N) {
					System.out.println("No economy class passengers waiting to be checked-in");
				}

				//the thread will randomly sleep for any milliseconds up to 1000
				Thread.sleep(random.nextInt(1000));
			}

		}

	}

	// method to pick Business or First class passengers form the queue q2
	public Passenger BusinessFirstPicker() throws InterruptedException {
		
		//random class to make the thread sleep for random time within defined limits
		//used at the end of the code block
		Random random = new Random();

		//synchronised code block on the object lock which is shared between code blocks of different methods
		synchronized (lock) {
			while (true) {

				try {
					//if condition to release the lock if there are no passengers in the q2 linked list
					if (q2.size() == 0) {
						lock.wait();
					}
					
					//for loop to go through the linked list q2
					for (int i = 0; i <= q2.size(); i++) {

						// Passenger object p is the first element in the q2 linked list
						//remove() method will remove the object from the linked list
						Passenger p = q2.removeFirst();

						//if condition to process the p object as indicated if the class in first or business 
						if (p.getpClass().equalsIgnoreCase("first") || p.getpClass().equalsIgnoreCase("business")) {
							
							//for passenger travelling by first or business class baggage b object is created
							Baggage b = p.createAbag(p);
							
							//the check-in status is set as true
							p.setCheckInStatus(true);
							
							//the passenger is added in the linked list Checkedin
							Checkedin.add(p);

							//This should be visible on GUIMain
							System.out.println(p.getpClass() + " class passenger, " + p.getFullName()
									+ " travelling by " + p.getflightCode()
									+ " is Checking in at Business & First Class " + "Ch// this will print to the log report of programme executioneck-in Desk");
							System.out.println("The check-in bag weight is " + b.getWeight()
									+ " Kg and bag dimensions are " + b.getHeight() + " X " + b.getBreadth() + " X "
									+ b.getWidth() + " cubic inches. Therefore, the baggage " + "volume is "
									+ b.baggageVolume() + " cubic inches");
							System.out.println("The check-in bag is overweight by " + b.excessBaggageWeight() + " kg.");
							System.out.println("The check-in bag exceeds volume allowance by " + b.excessBaggageVolume()
									+ " cubic inches.");
							System.out.println("The excess baggage fee is " + b.excessBaggageFee() + " GBP.");
							System.out.println("Total passengers checked in is " + Checkedin.size());

							// this will print to the log report of programme execution
							String passengerClass = p.getpClass();
							String name = p.getFullName();
							String flightCode = p.getflightCode();
							Log log = Log.getInstance();
							log.logCheckInDeskEconomy(passengerClass, name, flightCode);

							// remove the passenger from the set to avoid duplication
							if (q2.contains(p)) {
								q2.remove(p);
							}
							
							//once the code block finishes the lock is released and other threads are notified
							lock.notifyAll();
						}
					}
				} catch (NullPointerException | NoSuchElementException N) {
					System.out.println("No First or Business class passengers waiting to be checked-in");
				}
				Thread.sleep(random.nextInt(10));
			}

		}
	}

	public LinkedList<Passenger> getQ() {
		return q1;
	}

	public LinkedList<Passenger> getQQ() {
		return q2;
	}

	public LinkedList<Passenger> getQ1() {
		return Checkedin;
	}

	public ArrayList<Passenger> getQ2() {
		return security;
	}

	public ArrayList<Passenger> getQ3() {
		return boarding;
	}

	// This method will put customers in the security queue following check-in
	public void securityQueue(Passenger p) {

		try {
			security.add(p);

		} catch (NullPointerException N) {
			System.out.println("All passengers have cleared security");

		}

	}

	// This method will put customers in the security queue following check-in
	public void Checkedin(Passenger p) {

		try {
			Checkedin.add(p);

		} catch (NullPointerException N) {
			System.out.println("All passengers have checked-in");

		}

	}

//This method will put customers in a priority boarding queue following security
	public void boardingPlaneQueue(Passenger p) {

		try {
			boarding.add(p);
		} catch (NullPointerException N) {
			System.out.println("The boarding queue is empty");

		}

	}

	// This method will move passengers from boarding queue into the appropriate
	// planes

	public void placer() {
		// AtomicInteger count = new AtomicInteger();

		for (Map.Entry<String, String> fentry : f.entrySet()) {
			int count = 0;

			for (Passenger p : Checkedin) {
				if (fentry.getKey().equalsIgnoreCase(p.getflightCode())) {
					// count.addAndGet(1);
					count++;

				}
			}
			System.out.println(fentry.getKey() + "  " + count + "   " + "Checked In");

		}
	}

	public void placer1() {
		// AtomicInteger count = new AtomicInteger();

		for (Map.Entry<String, String> fentry : f.entrySet()) {
			int count = 0;

			for (Passenger p : security) {
				if (fentry.getKey().equalsIgnoreCase(p.getflightCode())) {
					// count.addAndGet(1);
					count++;

				}
			}
			System.out.println(fentry.getKey() + "  " + count + "   " + "have cleared security check");

		}
	}

	public void placer2() {
		// AtomicInteger count = new AtomicInteger();

		for (Map.Entry<String, String> fentry : f.entrySet()) {
			int count = 0;

			for (Passenger p : boarding) {
				if (fentry.getKey().equalsIgnoreCase(p.getflightCode())) {
					// count.addAndGet(1);
					count++;

				}
			}
			System.out.println(fentry.getKey() + "  " + count + "   " + "have boarded");

		}
	}

	public void addObserver(GUIMain guiMain) {
		// TODO Auto-generated method stub

	}

}
