package Model;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Random;
import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import View.GUIMain;

public class PassengersInQueue {

	// Object lock is used to synchronise code blocks for producer-consumer model
	// based threading
	private Object lock = new Object();

	// Constant used to limit the number if passengers in the queue
	private final int LIMIT = 25;

	// Linked list shared data structures to store passengers generated by the
	// Producer thread
	private volatile LinkedList<Passenger> q1 = new LinkedList<Passenger>();
	private volatile LinkedList<Passenger> q2 = new LinkedList<Passenger>();

	// Linked list shared data structure to stored passengers who have checked in
	private volatile LinkedList<Passenger> Checkedin = new LinkedList<Passenger>();
	private volatile LinkedList<Passenger> forSecurity = new LinkedList<Passenger>();

	// Linked list shared data structure to stored passengers who have cleared
	// security
	private volatile LinkedList<Passenger> clearedSecurity = new LinkedList<Passenger>();

	// Linked list shared data structure to stored passengers who have cleared
	// security
	private volatile LinkedList<Passenger> boarding = new LinkedList<Passenger>();

	// our flight fleet
	// FlightList planes = new FlightList().populate();

	// collection of passengers from the input file 'passengers'
	PassengerSet customers1 = new PassengerSet().populate();

	// Baggage object
	Baggage b;

	// method used in producer thread to populate the linked list data structures
	public void puti() throws InterruptedException {

		System.out.println("Passengers in Check-in queue");
		Passenger p1;

		while (true) {

			// synchronised code block on the object lock which is shared between code
			// blocks of different methods
			synchronized (lock) {

				// pick random passenger object p1 from the pool of passengers
				p1 = customers1.rando();

				// add passenger and baggage in linked list q1 and q2
				q1.add(p1);
				q2.add(p1);

				System.out.format(p1.getpClass() + " passenger," + p1.getFullName() + " travelling by flight "
						+ p1.getflightCode() + " is in the check-in queue.");
				System.out.println();

				// released the lock if the size of q2 (can also be q1) reaches the specified
				// LIMIT constant
			
				  while (q1.size() == LIMIT) { lock.wait(); }
		 		 

				// this will print to the log report of programme execution
				String name = p1.getFullName();
				Log log = Log.getInstance();
				log.logCheckInQueue(name);

				// remove the passenger from the set to avoid duplication
				if (customers1.cont(p1)) {
					customers1.removeOb(p1);

				}
      
				// once the synchronised code block is finished the lock is free and other
				// threads are notified to acquire the lock
				lock.notifyAll();
			}
		}
	}

	// method to pick Economy class passenger as the Consumer form the linked list
	// q1
	public Passenger EconomyPicker() throws InterruptedException {

		// random class to make the thread sleep for random time within defined limits
		// used at the end of the code block
		Random random = new Random();

		// synchronised code block on the object lock which is shared between code
		// blocks of different methods
		synchronized (lock) {
			while (true) {

				try {

					// if condition to release the lock if there are no passengers in the q1 linked
					// list
					if (q1.size() == 0) {
						lock.wait();
						System.out.println("WAITING ECO.............. ");
					}

					// for loop to go through the linked list q1
					for (int i = 0; i <= q1.size(); i++) {
						
						try { 
						// Passenger object p is the first element in the q1 linked list
						// remove() method will remove the object from the linked list
						Passenger p = q1.peekFirst();
						
						//boolean o = !p.getpClass().equalsIgnoreCase("economy");
						//if (q1.contains(o)) {							
							//lock.wait();							
						//}
								

						// if condition to process the p object as indicated if the class in economy
						if (p.getpClass().equalsIgnoreCase("economy")) {
							
							q1.remove();

							// for passenger travelling by economy class baggage b object is created
							Baggage b = p.createAbag(p);

							// the check-in status is set as true
							p.setCheckInStatus(true);

							// the passenger is added in the linked list Checkedin
							Checkedin.add(p);
							forSecurity.add(p);

							// This should be visible on GUIMain
							System.out.println(p.getpClass() + " class passenger, " + p.getFullName()
									+ " travelling by " + p.getflightCode() + " is Checking in at Economy Class "
									+ "Check-in Desk");
							System.out.println("The check-in bag weight is " + b.getWeight()
									+ " Kg and bag dimensions are " + b.getHeight() + " X " + b.getBreadth() + " X "
									+ b.getWidth() + " cubic inches. Therefore, the baggage " + "volume is "
									+ b.baggageVolume() + " cubic inches");
							System.out.println("The check-in bag is overweight by " + b.excessBaggageWeight() + " kg.");
							System.out.println("The check-in bag exceeds volume allowance by " + b.excessBaggageVolume()
									+ " cubic inches.");
							System.out.println("The excess baggage fee is " + b.excessBaggageFee() + " GBP.");
							System.out.println("Total passengers checked in is " + Checkedin.size());
							System.out.println("Passengers ready for security: " + forSecurity.size());
                            
                            
							// this will print to the log report of programme execution
							String passengerClass = p.getpClass();
							String name = p.getFullName();
							String flightCode = p.getflightCode();
							Log log = Log.getInstance();
							log.logCheckInDeskEconomy(passengerClass, name, flightCode);
							
							// once the code block finishes the lock is released and other threads are
							// notified
							lock.notifyAll();
						
						}
						
						else {

							q1.add(p);
							System.out.println("After economy checkin the q1 size is " + q1.size());
							
							// remove the passenger from the set to avoid duplication
							if (q1.contains(p)) {
								q1.remove(p);}
							System.out.println("After economy checkin the q1 size is " + q1.size());
							
							// once the code block finishes the lock is released and other threads are
							// notified
							lock.wait();
								
						}
							
					
						} catch (NullPointerException N) {
							//System.out.println("No economy class XXXXXXXX passengers waiting to be checked-in");
						}

					}

					

					// catches two exceptions
				} catch (NullPointerException | NoSuchElementException N) {
					//System.out.println("No economy class passengers waiting to be checked-in");
				}finally {

				// the thread will randomly sleep for any milliseconds up to 1000
				//Thread.sleep(random.nextInt(1000));
				lock.wait();
				System.out.println("The state in finall block of the economy is "+ Thread.currentThread().getState());
				}
			}

		}

	}

	// method to pick Business or First class passengers form the queue q2
	public Passenger BusinessFirstPicker() throws InterruptedException {

		// random class to make the thread sleep for random time within defined limits
		// used at the end of the code block
		Random random = new Random();

		// synchronised code block on the object lock which is shared between code
		// blocks of different methods
		synchronized (lock) {
			while (true) {

				try {
					// if condition to release the lock if there are no passengers in the q2 linked
					// list
					if (q1.size() == 0) {
						lock.wait();
						System.out.println("WAITING BUSI.............. ");
					}

					// for loop to go through the linked list q2
					for (int i = 0; i <= q1.size(); i++) {
						
						try {

						// Passenger object p is the first element in the q2 linked list
						// remove() method will remove the object from the linked list
						Passenger p = q1.peekFirst();

						//boolean o = !p.getpClass().equalsIgnoreCase("first")|| !p.getpClass().equalsIgnoreCase("business");
						//if (q1.contains(o)) {
							//lock.wait();
							//}
										
						
						
						// if condition to process the p object as indicated if the class in first or
						// business
						if (p.getpClass().equalsIgnoreCase("first") || p.getpClass().equalsIgnoreCase("business")) {
							
							
							q1.remove();

							// for passenger travelling by first or business class baggage b object is
							// created
							Baggage b = p.createAbag(p);

							// the check-in status is set as true
							p.setCheckInStatus(true);

							// the passenger is added in the linked list Checkedin
							Checkedin.add(p);
							forSecurity.add(p);

							// This should be visible on GUIMain
							System.out.println(p.getpClass() + " class passenger, " + p.getFullName()
									+ " travelling by " + p.getflightCode()
									+ " is Checking in at Business & First Class Check-in Desk");
							System.out.println("The check-in bag weight is " + b.getWeight()
									+ " Kg and bag dimensions are " + b.getHeight() + " X " + b.getBreadth() + " X "
									+ b.getWidth() + " cubic inches. Therefore, the baggage " + "volume is "
									+ b.baggageVolume() + " cubic inches");
							System.out.println("The check-in bag is overweight by " + b.excessBaggageWeight() + " kg.");
							System.out.println("The check-in bag exceeds volume allowance by " + b.excessBaggageVolume()
									+ " cubic inches.");
							System.out.println("The excess baggage fee is " + b.excessBaggageFee() + " GBP.");
							System.out.println("Total number of passengers who have checked in is " + Checkedin.size());
							System.out.println("Passengers ready for security: " + forSecurity.size());

							// this will print to the log report of programme execution
							String passengerClass = p.getpClass();
							String name = p.getFullName();
							String flightCode = p.getflightCode();
							Log log = Log.getInstance();
							log.logCheckInDeskEconomy(passengerClass, name, flightCode);
							
							// once the code block finishes the lock is released and other threads are
							// notified
							lock.notifyAll();
													
						}
						
						else {

							q1.add(p);
							System.out.println("After First checkin the q1 size is " + q1.size());
							

							// remove the passenger from the set to avoid duplication
							if (q1.contains(p)) {
								q1.remove(p);}
							
							System.out.println("After First checkin the q1 size is " + q1.size());	

							// once the code block finishes the lock is released and other threads are
							// notified
							lock.wait();
							
							
						}
							
							
						}catch (NullPointerException| NoSuchElementException N) {
							//System.out.println("No First or Business class XXXXXXXXXX  passengers waiting to be checked-in");
						}
						
						
					}
				} catch (NullPointerException | NoSuchElementException N) {
					//System.out.println("No First or Business class passengers waiting to be checked-in");
				}finally {

					// the thread will randomly sleep for any milliseconds up to 1000
					//Thread.sleep(random.nextInt(1000));
					lock.wait();
					System.out.println("The state in finally block of the business is "+ Thread.currentThread().getState());
					}
			}

		}
	}

	// method to pick passengers who have checked in for security
	public Passenger securityPicker() throws InterruptedException {

		// random class to make the thread sleep for random time within defined limits
		// used at the end of the code block
		Random random = new Random();

		// synchronised code block on the object lock which is shared between code
		// blocks of different methods
		synchronized (lock) {
			while (true) {
                            
				try {
					// if condition to release the lock if there are no passengers in the linked
					// list
					if (forSecurity.size() == 0) {
						System.out.println("The thread before wait is invoked "+Thread.currentThread().getState());
						lock.wait();
						System.out.println("The thread after wait is invoked "+Thread.currentThread().getState());
					}

					// for loop to go through the linked list 
					for (int i = 0; i <= forSecurity.size(); i++) {

						// Passenger object p is the first element in the linked list
						// remove() method will remove the object from the linked list
						Passenger p = forSecurity.removeFirst();
						
						//if the passengers have checked in
						if (p.getCheckInStatus() == true) {
							// the passenger is added in the linked list security
							clearedSecurity.add(p);
							
							
							// This should be visible on GUIMain
							System.out.println(p.getpClass() + " class passenger, " + p.getFullName()
									+ " travelling by " + p.getflightCode() + " is in the security queue.");
							System.out.println("Total number of passengers who have cleared security is "
									+ clearedSecurity.size());

							// remove the passenger from the set to avoid duplication
							if (forSecurity.contains(p)) {
								forSecurity.remove(p);
							}

							

						}
						
						// once the code block finishes the lock is released and other threads are
						// notified
						lock.notifyAll();
						System.out.println("After notifyAll is invoked"+Thread.currentThread().getState());
						
					}
					
					

				} catch (NullPointerException | NoSuchElementException N) {
					//System.out.println(forSecurity.size());
					//.out.println("State after null pointer exception: "+ Thread.currentThread().getState());
					//.out.println("No passengers in the security queue");
				}finally {
				//Thread.sleep(random.nextInt(100));
				lock.wait();
				System.out.println("State in finally: "+ Thread.currentThread().getState());

				}
			}

		}
	}

	// method to pick passengers who have cleared security for boarding
	public Passenger boardingPicker() throws InterruptedException {

		// random class to make the thread sleep for random time within defined limits
		// used at the end of the code block
		Random random = new Random();

		// synchronised code block on the object lock which is shared between code
		// blocks of different methods
		synchronized (lock) {
			while (true) {

				try {
					// if condition to release the lock if there are no passengers in the linked
					// list
					if (clearedSecurity.size() == 0) {
						lock.wait();
					}

					// for loop to go through the linked list 
					for (int i = 0; i <= clearedSecurity.size(); i++) {
						
									
						// Passenger object p is the first element in the linked list
						// remove() method will remove the object from the linked list
						Passenger p = clearedSecurity.removeFirst();

						if (p.getCheckInStatus() == true) {
							// the passenger is added in the linked list security
							boarding.add(p);

							// This should be visible on GUIMain
							System.out.println(p.getpClass() + " class passenger, " + p.getFullName()
									+ " travelling by " + p.getflightCode() + " is in the boarding queue.");
							System.out.println("Total number of passengers boarded is " + boarding.size());

							Thread.sleep(random.nextInt(1000));

							// remove the passenger from the set to avoid duplication
							if (clearedSecurity.contains(p)) {
								clearedSecurity.remove(p);
							}

							
						}
						
						// once the code block finishes the lock is released and other threads are
						// notified
						lock.notifyAll();
					}

				} catch (NullPointerException | NoSuchElementException N) {
					//System.out.println("No passengers in the boarding queue");
				}finally {

					// the thread will randomly sleep for any milliseconds up to 1000
					//Thread.sleep(random.nextInt(1000));
					lock.wait();
					System.out.println("The state in finall block of the boarding is "+ Thread.currentThread().getState());
					}
			}

		}
	}

	public LinkedList<Passenger> getQ() {
		return q1;
	}

	public LinkedList<Passenger> getQQ() {
		return q2;
	}

	public LinkedList<Passenger> getQ1() {
		return Checkedin;
	}

	public LinkedList<Passenger> getQ2() {
		return forSecurity;
	}

	public LinkedList<Passenger> getQQ2() {
		return clearedSecurity;
	}

	public LinkedList<Passenger> getQ3() {
		return boarding;
	}

	public void addObserver(GUIMain guiMain) {
		// TODO Auto-generated method stub

	}

}
